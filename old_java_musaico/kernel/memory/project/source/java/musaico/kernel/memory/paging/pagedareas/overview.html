<html>
<body>
  <p>
    Paged areas implementing specific swapping in and out
    of memory, persistent storage, and so on.  Every Task has
    one or more PagedArea(s).  Tasks may share PagedAreas,
    depending on the privileges set in their corresponding
    Segments.
  </p>

  <p>
    Each PagedArea corresponds to a VirtualBuffer which
    accesses the Pages in the PagedArea.  For example,
    a user space Process might have a heap PagedArea and
    a memory-mapped object PagedArea read in from an OSystem:
  </p>

  <pre>
                           UserTask
                              |
                  ____________|____________
                 |                         |
                heap                mmapped object
                 |                         |
            VirtualBuffer           VirtualBuffer
                 |                         |
              Segment                   Segment
                 |                         |
          MemoryOnlyPageArea          ONodePagedArea
             |          |                  |       |
             |      NoSwapper              |    ONodeToBufferSwapper
       ______|______             __________|_____________   \
      | | | | | | | |           |           | | | | | | |  ONode
       BufferPages...       BufferPage       ONodePages...__/
      | | | | | | | |           |
         Buffers...          Buffer
  </pre>

  <p>
    In this example, all of the heap for the UserTask is in memory
    at once.  So each time a Field is retrieved from the
    VirtualBuffer for the heap, a direct call is made to the
    corresponding BufferPage in the paged area.  For example,
    Field # 13 in the heap probably refers to Field # 13 in the
    first BufferPage's Buffer, while Field # 1,000,000 might refer
    to a Field in the 244th BufferPage's Buffer.
  </p>

  <p>
    The mmapped object in the example, however, provides page swapping.
    So some areas of the VirtualBuffer representing the mmapped
    object will directly access in-memory BufferPages.  Others will
    induce PageFaults, forcing data to be read in from the
    object system before Fields can be manipulated in the
    VirtualBuffer.  For example, Field # 13 in the mmapped object
    probably refers to Field # 13 in the first BufferPage's Buffer.
    On the other hand, Field # 1,000,000 probably refers to a
    (swapped-out) ONodePage.  Retrieving it from the mmapped
    object VirtualBuffer will induce a PageFault, swapping the
    244th ONodePage into an in-memory BufferPage.  Once the
    swap is complete, the 1,000,000th field can be returned.
  </p>

  <p>
    (Of course this exact scenario is unlikely, since in a typical
    Musaico implementation, even heap PagedArea is swapped
    in and out from an object system dedicated as "swap space".
    Furthermore there may be additional swapping provided, such
    as swapping BufferPages into an easier-to-access
    "direct access Objects" cache, or swapping between fast
    ONodePages and slower ones for going into / coming out of
    long term hibernation, and so on.)
  </p>

  <p>
    The typical relations between PagedArea and other
    classes controlling memory in a Musaico kernel are as follows:
  </p>

  <pre>
    0..n VirtualBuffers
           |
        1  V
        Segment
           |
         1 V     0..n   1
      PagedArea ---------> SwapSystem
           |               1 | (SwapStates, Swappers and so on)
         1 V                 |
       PageTable             |
           |            1..n |
      1..n V   0..n   1      V
         Page ----------> SwapState
          /_\             + pageSize etc
      _____|____________
      |         |       |
      Object  Buffer  ONode
      cache    page   page
       page     |       |
        |       |       |
      Object  Buffer  ONode ---- persistent data
                |
           0..n |
              Field
  </pre>




  <br> </br>
  <br> </br>
  <hr> </hr>
  <br> </br>
  <br> </br>


  <pre>
    Copyright (c) 2009 Johann Tienhaara
    All rights reserved.

    This file is part of Musaico.

    Musaico is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    Musaico is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with Musaico.  If not, see <http://www.gnu.org/licenses/>.
  </pre>
</body>
</html>
