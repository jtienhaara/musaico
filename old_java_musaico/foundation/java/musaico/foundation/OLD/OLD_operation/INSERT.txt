insert ( input, input_index, insert_at_indices, elements_to_insert )
    when insert_at_indices is empty
        then return input
    otherwise
        when head ( insert_at_indices ) lessThanOrEqualTo ( input_index )
            then elements_to_insert,
                 insert ( input, input_index,
                          tail ( insert_at_indices ), elements_to_insert )
        otherwise
            range ( input, input_index, Bounds.CLOSED,
                           head ( insert_at_indices ), Bounds.OPEN ),
            insert ( input, head ( insert_at_indices ),
                            insert_at_indices, elements_to_insert )

The builder automatically decides how many elements to pull
out e.g. Countable or Cyclical, and when to cut off induction
because the caller doesn't want any more elements anyway, or because
the output is now infinite.




difference ( input1, input2, same, different )
    when input1 is empty
        when input2 is empty
            return different
        otherwise
            when same contains head ( input2 )
                return difference ( input1, tail ( input2 ),
                                    { same, head ( input2 ) },
                                    different )
            otherwise
                return difference ( input1, tail ( input2 ),
                                    same,
                                    { different, input2 } )
    otherwise
        when input2 is empty
            when same contains head ( input1 )
                return difference ( tail ( input1 ), input2,
                                    { same, head ( input1 ) },
                                    different )
            otherwise
                return difference ( tail ( input1 ), input2,
                                    same,
                                    { different, input1 } )
        otherwise
            when input2 contains head ( input1 )
                when input1 contains head ( input2 )
                    difference ( tail ( input1 ), tail ( input2 ),
                                 { same, head ( input1 ), head ( input2 ) },
                                 different )
                otherwise
                    when same contains head ( input2 )
                        difference ( tail ( input1 ), tail ( input2 ),
                                     { same, head ( input1 ),
                                       head ( input2 ) },
                                     different )
                    otherwise
                        difference ( tail ( input1 ), tail ( input2 ),
                                     { same, head ( input1 ) },
                                     { different, head ( input2 ) } )
            otherwise
                when input1 contains head ( input2 )
                    difference ( tail ( input1 ), tail ( input2 ),
                                 { same, head ( input2 ) },
                                 { different, head ( input1 ) } )
                otherwise
                    when same contains head ( input2 )
                        difference ( tail ( input1 ), tail ( input2 ),
                                     { same, head ( input2 ) },
                                     { different, head ( input1 ) } )
                    otherwise
                        difference ( tail ( input1 ), tail ( input2 ),
                                     same,
                                     { different, head ( input1 ),
                                                  head ( input2 ) } )


Instead of Pipe.length ( Context ), if we have Pipe.position ( Context )
then we can easily read ( ... ) head and tail, and recurse as much as we like.

Still a lot of error handling to do, but better than what we've got so far...



Cursor<VALUE>
    private final Pipe<VALUE> pipe;
    private final Context context;
    // MUTABLE:
    private long index; 
    public VALUE head ()
    {
        VALUE [] head = this.pipe.type ( context ).array ( 1L );
        final int num_read =
            this.pipe.read ( head, 0, 1,
                             this.index, this.pipe.stream (), this.context );
        if ( num_read == 0 )
        {
            violation...;
        }

        return head [ 0 ];
    }

    public Cursor<VALUE> tail ()
    {
        // Not exacty functional programming...
        this.index ++;
        return this;
    }
}











Term = [ element 0, 1, 2, 3, ... ]
Pipe = [ stream finite(countable), cycle, other, error, ... ]
Application = [ pipe input, insert_at, inserts, output, ... ]

3-dimensional "matrix" (whatever that construct is called... tensor???)

Actually Pipe is an artificial construct
Really it's just:

Term = [ element 0, 1, 2, 3, ... ]
Application = [ Term input, insert_at, inserts, output, ... ]

where Term can be Countable, Cyclical, Acyclical, Error, ...

Insert:
            0  1  2  3  4  5  6  ...
Input     [                          ]
Insert at [                          ]
Inserts   [                          ]
Output    [                          ]

Or more aptly:

            0  1  2  3  4  ...        Input          Output
Insert at [                    ]  0 [        ]   0 [        ]
Inserts   [                    ]  1 [        ]   1 [        ]
                                  2 [        ] = 2 [        ]
                                  3 [        ]   3 [        ]
                                  4 [        ]   4 [        ]
                                ... [        ] ... [        ]


Insert_at iterator w: Insert_at[0], Insert_at[1], ...
Inserts iterator x:   Inserts[0], Inserts[1], ..., etc
Input iterator y:     Input[0], Input[1], ...
Output iterator z:    Output[0], Output[1], ...
Induction:            w >= insert_at.length : input[0..N]
                        | insert_at[w] <= y : inserts [0..N], w ++
                                            | input[y], y ++
N.b. [0..N] can be infinite.


Stream { Term, long index }
induction ( Stream input, Stream [] parameters, Stream output )
  ??? returns the stream from which to pull the next element???
Then the caller of induction can decide whether a Term needs to be split
or left intact.

??? too slow???

induction ( Stream input, Stream [] parameters, Stream output ) : Stream

Stream.head ()
(combine Cursor & current List concept of streams)




++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

AbstractPipe<INPUT, OUTPUT>
    extends Operation<Binding<INPUT>, Pipe<INPUT, OUTPUT>>
{
    @Override
    public Maybe<Pipe<INPUT, OUTPUT>> apply (
            Term<Binding<VALUE>> maybe_bindings
            )
    {
        if ( ! ( maybe_bindings instanceof Countable ) )
        {
            return ...Error...;
        }

        final Countable<Binding<VALUE>> bindings =
            (Countable<Binding<VALUE>>) maybe_bindings;
        for ( Binding<VALUE> binding : bindings )
        {
            final Term<VALUE> input = binding.term ();
            final Term<VALUE> output
        }
    }
}

Insert<VALUE>
@Override
public Maybe<Insert<VALUE>> apply (
            Term<Binding<VALUE>> input
            )
{
}

Binding<VALUE>
    extends Transform<Context, Term<VALUE>>
{
    ...;
}



++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Maybe the first time we call apply () it sets up a stateful copy
of itself, and from then on, anyone who calls apply () on that
copy changes the state.

Input<VALUE>
    implements Pipe<VALUE, VALUE>
{
    private final Serializable lock = new String ( "lock" );
    private final long offset;
    private final long minimumNumElements;
    private final Term<VALUE> [] buffer; // default = null;

    private Input<VALUE> next = null;
    private int numTerms = 0;

    private int termIndex = -1;
    private long index = -1L;

    public Maybe<Input<VALUE>> apply (
            Term<VALUE> input
            )
    {
        if ( this.buffer == null )
        {
            // Create a stateful instance of ourselves.
            final Input<VALUE> instance = new Input<VALUE> ( ..., Term[1] );
            final Maybe<Input<VALUE>> induction =
                instance.apply ( input );
            return induction;
        }

        synchronized ( this.lock )
        {
            if ( this.numTerms >= this.buffer.length )
            {
                // Chain.
                int next_buffer_size = this.buffer.length * 4;
                if ( next_buffer_size > 4096 )
                {
                    next_buffer_size = 4096;
                }

                final Input<VALUE> next =
                    new Input<VALUE> ( this, ..., Term[next_buffer_size] );
                return next.apply ( input );
            }

            this.buffer [ this.numElements ] = input;
            this.numElements ++;

            this.lock.notify (); // Let 1 thread wake up (if any).
        }

        return this;
    }

    public Term<VALUE> read (
            final Concurrency<VALUE> later
            )
    {
        final Input<VALUE> this_input;
        final Term<VALUE> output;
        synchronized ( this.lock )
        {
            if ( this.termIndex >= this.numTerms )
            {
                if ( this.next != null )
                {
                    return this.next.read ( later );
                }

                later.onNotify (
                    this.lock,
                    new Runnable ()
                    {
                        @Override
                        public final void run ()
                        {
                            this_input.read ( later );
                        }
                    }
                    );
                return later.yield ();
            }

            output = this.buffer [ this.termIndex ];
            this.termIndex ++;
        }

        later.output ( output );
        return later.yield ();
    }
}

Insert<VALUE>
    implements Pipe<VALUE, VALUE>
{
    private final Serializable lock = new String ( "lock" );
    private final Input<?, Long> insertAts;
    private final Input<?, VALUE> inserts;
    private final Concurrency concurrency;

    private Term<Long> insertAt = null;

    public Maybe<Insert<VALUE>> apply (
            Term<VALUE> input
            )
    {
        synchronized ( this.lock )
        {
            if ( this.insertAt == null )
            {
                // Create a stateful instance of ourselves.
                final Insert<VALUE> instance = new Insert<VALUE> ( ..., 0L );
                final Maybe<Insert<VALUE>> induction =
                    instance.apply ( input );
                return induction;
            }
            else if ( this.insertAt == null )
            {
                this.insertAt = this.insertAts.read ( this.concurrency );
            }

            final Long insert_at = this.insertAt.head ().orNull ();
            !!!;
        }
    }
}





+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Pushing and induction don't mesh because we have 1 term to push but
it might take 10 apply()s to finish processing that 1 term.


++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

public class Buffer<VALUE>
{
    private final List<Term<VALUE>> queue;
    // MUTABLE:
    private int nextIndex = 0;
    // MUTABLE:
    private Pipe<?, VALUE> inputPipe = null;

    private final No<Term<VALUE>> eof = No<Term<VALUE>>;

    private final One<Buffer<VALUE>> step = One<this>;
    private final No<Buffer<VALUE>> terminate = No<Buffer<VALUE>>;

    public Buffer (
            Pipe<?, VALUE> input_pipe
            )
    {
        this.inputPipe = input_pipe;
        this.queue = new ArrayList<Term<VALUE>> ();
        this.nextIndex = 0;
    }

    public Buffer (
            Buffer<VALUE> that
            )
    {
        this.inputPipe = that.input_pipe;
        this.queue = that.queue;
        this.nextIndex = 0;
    }

    public read () : Maybe<Term<VALUE>>
    {
        sync {
            if ( this.nextIndex < 0 ) // Downstream is done reading.
            {
                return this.eof;
            }
            else if ( this.nextIndex >= this.queue.size () )
            {
                if ( this.inputPipe == null ) // Upstream is done writing.
                {
                    this.nextIndex = -1;
                    return this.eof;
                }

                this.inputPipe =
                    this.inputPipe.apply ( this.step )
                                  .orNull ();
                if ( this.nextIndex >= this.queue.size () )
                {
                    // Upstream did not feed us any terms.  We're done.
                    this.nextIndex = -1;
                    return this.eof;
                }
            }

            final Term<VALUE> term = this.queue.get ( this.nextIndex );
            this.nextIndex ++;
            return One<term>;
        }
    }

    public write ( Term<VALUE> ) : Maybe<Buffer<VALUE>>
    {
        sync {
            if ( this.nextIndex < 0       // Downstream is done reading.
                 || this.input == null )  // Upstream is done writing.
            {
                return this.terminate;
            }

            this.queue.add ( term );

            if ( ! ( term instanceof Countable ) )
            {
                // After an Infinite term or an Error and so on,
                // no more Terms can be accepted into this Buffer.
                this.input = null;
                return this.terminate;
            }

            return this.step;
        }
    }

    public void close ()
    {
        this.inputPipe = null;
    }

    // Can be null, if this buffer is disconnected.
    public Pipe<?, INPUT> inputPipe ()
    {
        return this.inputPipe;
    }
}


public Context
{
    public <INPUT extends Object>
        Context (
            Context that,
            Pipe<INPUT, ?> pipe,
            Buffer<INPUT> input_binding
            )
    {
        ...copy that except overwrite the specified binding...
    }

    public <INPUT extends Object>
        Maybe<Buffer<INPUT>> binding (
            Pipe<INPUT, ?> pipe
            )
    {
        ...;
    }

    public <INPUT extends Object>
        void bind (
            Pipe<VALUE, ?> pipe,
            Buffer<VALUE> input_binding
            )
    {
        ...;
    }
}


public Pipe<INPUT, OUTPUT>
    extends Operation<Buffer<OUTPUT>, Pipe<INPUT, OUTPUT>>
{
    private final One<Pipe<INPUT, OUTPUT>> step = One<this>;
    private final No<Pipe<INPUT, OUTPUT>> terminate = No<Pipe<INPUT, OUTPUT>>;

    private final Context context; // null for disconnected Pipe.
    private final Buffer<INPUT> input;

    public Maybe<Pipe<INPUT, OUTPUT>> apply ( Term<Buffer<OUTPUT>> outputs )
    {
        if ( this.context == null )
        {
            return this.close ( outputs );
        }

        for ( Buffer<OUTPUT> output : outputs )
        {
            final boolean is_stepping = this.step ( output );
            if ( ! is_stepping )
            {
                return this.close ( outputs );
            }
        }

        return this.step;
    }

    private No<Pipe<INPUT, OUTPUT>> close ( Term<Buffer<OUTPUT>> outputs )
    {
        if ( outputs instanceof Countable )
        {
            for ( Buffer<OUTPUT> output : outputs )
            {
                output.close ();
            }
        }
        else if ( outputs instanceof Cyclical )
        {
            final Cyclical<Buffer<VALUE>> cyclical = ()...;
            final Countable<Buffer<VALUE>> header = cyclical.header ();
            final Countable<Buffer<VALUE>> cycle = cyclical.cycle ();
            this.close ( header );
            this.close ( cycle );
        }
        // Else do nothing to the output buffers.

        return this.terminate;
    }

    public Pipe<INPUT, OUTPUT> from (
            Pipe<?, INPUT> pipe
            )
    {
        return this.from (
            new Buffer<INPUT> ( pipe )
            );
    }

    public Pipe<INPUT, OUTPUT> from (
            Buffer<INPUT> buffer
            )
    {
        if ( context == null ) violation;
        final Context context = new Context ( this.context, buffer );
        return this.from ( context );
    }

    public abstract Pipe<INPUT, OUTPUT> from (
            Context context
            );
        

    protected abstract boolean step ( Buffer<OUTPUT> output );


    public static final <XYZ>
        Term<XYZ> range (
            Term<XYZ> term,
            long from_index,
            long to_index
            )
    {
        ...
    }

    public static final long add (
            long index,
            Term<?> term
            )
    {
        if ( term instanceof Countable )
        {
            final Countable<?> countable = (Countable<?>) term;
            final long length = countabe.length ();
            if ( ( Long.MAX_VALUE - length ) < index )
            {
                return Long.MAX_VALUE;
            }
            else
            {
                return index + length;
            }
        }
        else
        {
            return Long.MAX_VALUE;
        }
    }
}

public Insert<VALUE>
    extends Pipe<VALUE, VALUE>
{
    private final Buffer<Long> insertAts;
    private final Buffer<VALUE> inserts;

    private Iterator<Long> insertIndices = null;
    private Term<VALUE> inputTerm = null;
    private long inputOffset = 0L;
    private long inputIndex = 0L;

    protected final boolean step ( Buffer<VALUE> output )
    {
        while ( this.insertIndices == null
                || ! this.insertIndices.hasNext () )
        {
            // Get the next insert-at indices parameter (if any).
            final Term<Long> next_insert_at =
                this.insertAts.read ().orNull ();
            if ( next_insert_at == null )
            {
                // No more insertions.
                this.insertIndices = null;
                break;
            }
            else
            {
                this.insertIndices = next_insert_at.iterator ();
            }
        }

        if ( this.insertIndices == null )
        {
            // No more insertions.
            if ( this.inputTerm != null )
            {
                // Flush the rest of the input.
                final Term<VALUE> remaining =
                    Pipe.range ( this.inputTerm,
                                 this.inputOffset,
                                 Countable.END );
                if ( remaining != null )
                {
                    Buffer<VALUE> step = output.write ( remaining ).orNull ();
                    this.inputTerm = null;
                    this.inputOffset = 0L;
                    this.inputIndex = Pipe.add ( this.inputIndex, remaining );
                    if ( step == null )
                    {
                        // Our output Pipe does not want anything more.
                        return false;
                    }
                    else
                    {
                        // We might still be able to read in another
                        // input Term.
                        return true;
                    }
                }
            }

            this.inputTerm = this.input.read ().orNull ();
            this.inputIndex = 0L;
            if ( this.insertIndices == null )
            {
                // No more insertions.
                if ( this.inputTerm == null )
                {
                    // No more inputs.
                    return false;
                }

                Buffer<VALUE> step = output.write ( this.inputTerm ).orNull ();
                this.inputTerm = null;
                this.inputIndex = 0L;
                if ( step == null )
                {
                    // Our output Pipe does not want to receive any more terms.
                    return false;
                }
                else
                {
                    // We might still be able to read in another input Term.
                    return true;
                }
            }
        }

        final long insert_index = this.insertIndices.next ().longValue ();
        if ( insert_index < 0L )
        {
            !!!;
        }
    }

    public abstract Insert<VALUE> from (
            Context context
            )
    {
        Context bound_context = context;

        final Buffer<VALUE> maybe_input =
            bound_context.binding ( this ).orNull ();
        if ( maybe_input == null )
        {
            final Buffer<VALUE> input = new Buffer<VALUE> ( this.input );
            bound_context = new Context ( this, input );
        }
        !!! not working...;
    }
}
