*** SEE BOTTOM ***

Flow<X>

Circuit
pull ( Flow<X> ) : FlowState<X>
push ( FlowState<X> ) : FlowState<X>

Flow<X> : Iterable<X>
+ Class<X>

FlowState<X>
+ BLOCKED
+ END
+ INCOMPATIBLE
+ AVAILABLE
  + one () : X
  + array () : X []
  + list () : List<X>
  + set () : Set<X>

Flow<X> : Iterable<FlowState<X>>
+ maybe path

***********

Circuit
+ pull () : Flow
+ push ( Class<X>, X ... ) : Flow
+ reject ( X ... ) : Flow

Flow
^
|-- Blocking
|-- End
|-- Flowing<X>
    + available () : int
    + flowClass () : Class<X>
    + flow () : X []
|-- Rejected
    + rejects () : X []

****************

Flow
+ pull ( Class<X> ) : X []
+ push ( Class<X>, X ... ) : FlowState
+ reject ( Violation violation, X ... ) : FlowState
+ state () : FlowState
+ violations () : Violation []

FlowState
+ AVAILABLE
+ BLOCKED
+ END
+ REJECTED


*********************************************************

2020-05-18

Board : Component
  Component [ N ] components
    Class<?> [] in
    Class<?> [] out
  Wire<?> [ W ] wires
    Class<?> wireClass
  int [] wiring

wiring:
0..N-1 :

3 indices to every wire / connection:
0        0        0
...      ...      ...
N - 1    W - 1    N - 1
from     wire     to

Or arguably just 2, and the wire can be extrapolated from
component out, component in.

0..N - 1: component structure indices
N..X - 1: component structures
  c + w: wire # (ins first, followed by outs)
X..Y - 1: wire structures
  w + 0: in from node #
  w + 1: out to node #
Y: # components

   0       1       2       3       4       5       6      7
[  4  ] [  7  ] [  9  ] [  12 ] [  14 ] [  16 ] [  18 ] [ 14 ]
 Comp0   Comp1   Comp2   Comp3    C0W0    C0W1    C0W2   C1W0

   8       9       10      11      12      13      14      15
[ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ] [  0  ] [  1  ]
  C1W1    C2W0   C2W1     C2W2    C3W0    C3W1   W0Fr     W0To

   16      17      18      19      20      21      22      23
[ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ] [ !!! ]
 W1Fr     W1To   W2Fr     W2To   W3Fr     W3To   W4Fr     W4To

[  4  ]
 #Comp

Maybe all we need is:

  Component [ N ]
  int [] wires (i = from component index #, i + 1 = to component index #)

No because order of the wires into / out of each component is important.
